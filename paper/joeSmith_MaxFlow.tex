\documentclass[conference]{IEEEtran}

% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.

\usepackage{clrscode}




% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
   \usepackage[pdftex]{graphicx}
   %declare the path(s) where your graphic files are
   %\graphicspath{{../pdf/}{../jpeg/}}
   \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amsfonts}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/

\usepackage{listings}
\usepackage{color}
\usepackage{graphics}


% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Maximum Flow Problems\\The Ford-Fulkerson Algorithm}


\author{\IEEEauthorblockN{Joe Smith}
\IEEEauthorblockA{Department of Math and Computer Science\\
Chapman University\\
Orange, California 92866\\
smith237@mail.chapman.edu}
}

\maketitle

\begin{abstract}
%\boldmath
In this survey paper, we will present the Maximum Flow problem, as well as the Ford-Fulkerson algorithm to solve it. The Maximum Flow problem is given a directed graph, one must find the path of greatest length from a source to a sink. We shall also discuss the history of its development, as well as discuss several applications of the problem, as well as its importance and advancements. After covering background of the topic, we discuss an implementation written in the Python programming language.
\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}
Flow networks are a specialized form of directed graph, and lead to an interesting array of real-life applications. There are several problems that can be modeled using flow networks, the Ford-Fulkerson algorithm is one of the most widely used algorithm in flow problems. It is a large improvement over the greedy algorithm, and one which is used to efficiently transport data and materials in areas such as data networks and transportation. It makes use of the foundations of graph theory, and expands upon the work on mathematicians who are attempting to work on discovering the maximum flow that can pass through a graph from a single source to a single sink.

It is an extremely important area of study, as it has massive implications throughout many practical applications. Fortunately, it is an area that is well understood mathematically. Rather than the typical thought of a graph representing a map of roads, or a list of connections, the flow network is used to represent a constant movement of objects through the graph. 

We'll begin with a discussion of the background of flow networks, which are a subset of directed graphs, giving a formal definition for them. Following will be a discussion of flow, along with a formal definition of what it means to "transfer material between nodes on a flow network." From there we will cover Maximum Flow problems in general, giving a basis for the problem along with several examples of applications. 

The next section will cover the greedy algorithm, and will show how it is an ineffective means for planning the flow of material through a flow network. The main portion of the paper is dedicated to the Ford-Fulkerson Algorithm itself, and will discuss its history, pseudocode of the algorithm, and a step-by-step example of the algorithm being used. The last section will discuss an implementation written in Python. Firstly, we start by smoothly flowing into a discussion of the problem area.

\section{Background}
%Applications
\subsection{Flow Networks}
An excellent definition of flow networks, a specific type of directed graph with additional constraints and properties, is given in CRLS:\\

A \textbf{flow network} $G\ =\ (V,\ E)$ is a directed graph in which each edge $(u,\ v) \in E$ has a non-negative \textbf{capacity} $c(u,\ v) \geq 0$. If $(u,\ v) \notin E$, we assume that $c(u,\ v) = 0$. We distinguish two vertices in a flow network: a \textbf{source} $s$ and a \textbf{sink} $t$. For convenience, we assume that every vertex lies on some path from the source to the sink. That is, for every vertex $v \in V$, there is a path $s \leadsto v \leadsto t$. The graph is therefore connected, and $|E| \geq |V|\ -\ 1$.\cite{CLRS:2001}\\

This means that a directed graph (that has no edges with a negative weight, also known as the capacity) can have two of its nodes highlighted, one marked as the source, and the other known as the sink. The source is where the "flow" is created, it is assumed that a constant amount of material or data is being generated from the source, and will flow through the network from there. The sink, is the destination point for the material/data from the source. It is the point where the data is eventually siphoned off to, and it is assumed that it can handle as much material/data as the edges leading to it can transport to the sink. Another important distinction is that the graph is connected, that is that there is a path that leads from every node from the source, as well as a path from every node to the sink. This ensures that the flow of the data has a clear path to travel, starting from the source, then proceeding from each node toward the sink.

\subsection{Flow}
Now that we have described a flow network, we can proceed to define a flow:\\

%Definition
Let $G\ =\ (V,\ E)$ be a flow network with a capacity function $c$. Let $s$ be the source of the network, and let $t$ be the sink. A \textbf{flow} in $G$ is a real-valued function $f\ :\ V\ \times\ V\ \rightarrow\ $ \textbf{R} that satisfies the following three properties:\\

\textbf{Capacity constraint:} For all $u, v \in V$, we require $f(u,\ v) \geq c(u,\ v)$.\\

\textbf{Skew symmetry:}  For all $u, v \in V$, we require $f(u,\ v)\ = - f(v,\ u)$.\\

\textbf{Flow Conservation:} For all $u \in V - \{s,\ t\}$, we require

\[\displaystyle\sum_{v \in V} f(u,\ v) = 0.\]

The quantity $f(u,\ v)$, which can be positive, zero, or negative, is called the \textbf{flow} from vertex $u$ to vertex $v$. the \textbf{value} of a flow $f$ is defined as

\[|f| = \displaystyle\sum_{v \in V} f(s,\ v),\]

that is, the total flow out of the source. It is important to note that the $|\dot|$ notation is in regard to the flow value of $f$, not the cardinality (size) or absolute value.\cite{CLRS:2001}

%Explanation
This is how flow through a flow network can be described. Given a valid flow network, it is possible to determine an amount of flow that is passing through two nodes. Each pair of vertices has a maximum capacity that limits how much flow can pass between the two, typically represented by the weight of their edge between the two. This can be represented by sending a certain amount of water through a pipe, and there are no issues, so long as the capacity of the pipe isn't reached. This over-pressurization would lead to a burst pipe. The next constraint is to ensure that the amount of flow between nodes is equal to the opposite of the reverse flow. If one passes a unit of materials from $u$ to $v$, then that means that there is negative one unit being passed from $v$ to $u$. 

Although this may seem to be a difficult concept to grasp, it is an important issue. If there is flow being passed from $u$ to $v$, then it will be counteracted by flow being passed from $v$ to $u$. This theme is important to building upon the third property, that of flow conservation. Each node has a total sum flow of zero flowing out of it. Based upon the property of skew symmetry, we can also say that the total sum of material flowing into a node is also zero. This is calculated by measuring the negative value of materials flowing in versus the positive value of materials flowing out of a node. This is a property of conservation, the only nodes that can actually 'produce' or 'remove' materials are the source and sink, respectively.

\begin{figure}[!t]                     
\centering                             
\includegraphics[width=3.5in]{weighted.pdf}
\caption{Flow Network}           
\label{fig:intro}                        
\end{figure}                           

It is also worthy to note that with this model, the concept of flow from $u$ to $v$ and $v$ to $u$ is combined into merely one positive value. If there are 10 units moving from $u$ to $v$, and 5 from $v$ to $u$, then the overall flow will be determined as 5 units flowing from $u$ to $v$. If there is any reason to keep track of the actual flow between nodes, then this information will be lost in this representation of graphs.

\subsection{Maximum Flow Problems}
Maximum flow problems come in many forms, but are typically represented using an undirected weighted graph. This graph has two special vertices, the source and the sink, and represent the start and end nodes on the graph. The problem seeks to find the greatest value that can be created from the source to the sink. Although there may be edges which have a large capacity, they may be limited by a restrictively low-capacity edge that connects to the sink.

For instance, imagine an internetwork connecting various cities. There is a router in Orange, CA that is trying to direct packets to a server in Boston, MA. It may find that the fastest route is not the physically shortest, due to the quality of the link. The ``fastest link'' in this case generally means the one that can pass along the most data from point to point. Unfortunately, because there can be constrictions in terms of capacity further down the path, it can be ineffective to attempt to send the maximum amount of data through a single network link without understanding the full path. If a customer has a 1000MB/s line with ISP A, and a 100 MB/s line with ISP B, then it may seem most effective to tunnel most traffic through ISP A. However, if the destination server has a 1MB/s connection with ISP A, and a 100MB/s connection with ISP B, it would make most sense instead to use the connection with the second ISP. As this shows, the effect of the algorithm used to determine the maximum flow is extremely important.

\section{The Greedy Algorithm}
The greedy algorithm to find the maximum flow of a flow network, is one which may seem to be effective at first, but turns out to have greater costs associated with it than initially apparent. This approach is to start at the source, and move to the next node that is connected by an edge with the greatest weight. (This shows that the edge with most weight is also the one with the most flow.) From there, one must look at the nodes connected to the current node, and choose the one that is attached by the most flow. After this is completed, the process is repeated until the sink node is reached. So after one sends that much "material" through that path, the flow is increased by that amount.

Unfortunately, this process doesn't seem to work out very well in practice. Imagine a series of tracks connecting various railroad stations across a country. Each train must ship a certain amount of freight each day, and if they were to follow this algorithm, craziness would ensue. If a train were to depart the station and carried 200 train cars, but then arrived at the station at the same time as another 200 car train from another station, there would be deadlock and supreme brutality as trains attempted to squeeze through smaller, backwater stations with any sort of efficiency. What is needed is a much more thoroughly planned and methodical approach.


\section{Ford-Fulkerson Algorithm}
\subsection{History}
The Ford-Fulkerson algorithm actually has an interesting history. 
The algorithm was developed in 1956 by Lester Randolph Ford and Delbert Ray Fulkerson. The paper was published in \textit{Flows in Networks} at Princeton University. This was based upon research performed by Russian mathematicians, who were attempting to discover the most effective means by which trains could carry loads of cargo in a network of train stations. Because this was the height of the Cold War, there were American scientists, politicians, and mathematicians who were closely looking into the research coming out of Russia. Many of these mathematicians were interested in the work with maximum flow, and realized that it had other uses as well. By examining a series of train stations and routes, it is possible to determine where the most strategic bomb placement would be. By knocking out the most used railways, it is possible to ensure that the most damage possible would be dealt to the Russians.

\subsection{Algorithm}
The Ford-Fulkerson algorithm can be written in pseudocode\cite{CLRS:2001} as:

\begin{codebox}
\Procname{$\proc{Ford-Fulkerson}(G,s,t)$}
\li \For each edge $(u,\ v) \in E[G]$
\li \Do $f[u,\ v] \leftarrow 0$
\li $f[v,\ u] \leftarrow 0$
\End
\li \While there exists a path $p$ \\from $s$ to $t$ in the residual network $G_f$
\li \Do $c_f(p) \leftarrow$ min$\{c_f(u,\ v) : (u,\ v)$ is in $p\}$
\li \For each edge $(u,\ v)$ in $p$
\li \Do $f[u,\ v] \leftarrow f[u,\ v] + c_f(p)$
\li $f[v,\ u] \leftarrow - f[u,\ v]$
\End
\end{codebox}

The first step of the algorithm is to set the value of the flow between each node equal to zero. This is accomplished by iterating through each node, and setting the value of each edge that's connected to it to zero. This is an important step in order to clear values and prepare for flow to be sent through the flow network. Also, the reverse direction for each node's flow is also set to zero. Due to $f(u,\ v) = - f(v,\ u)$, it is necessary to clear the values of both directions.

After this preliminary step, the residual graph is checked for any remaining paths that have spare capacity that lead from the source $s$ to the sink $t$. If there does indeed exist such a path, then the path will be used to carry flow from the source to the sink. The capacity of the path is set to be equal to the capacity of the node with the least available capacity. Then for each edge $(u,\ v)$ that is in the path, it's flow is set to be increased by the capacity, and the opposite direction, $(v,\ u)$ is set to the negative of $f(u,\ v)$.

This is repeated until no more paths with available flow are found.

\subsection{Example}
\begin{figure}[t]                     
\centering                             
\includegraphics[width=3.5in]{weighted_ex_2.pdf}
\caption{Initial Flow Network}           
\label{fig:network1}                        
\end{figure}                           

\begin{figure}[t]                     
\centering                             
\includegraphics[width=3.5in]{weighted_ex_2b.pdf}
\caption{Step 2: Flow Network}           
\label{fig:network2}
\end{figure}                           

\begin{figure}[t!]                     
\centering                             
\includegraphics[width=3.5in]{weighted_ex_2c.pdf}
\caption{Step 3: Flow Network}           
\label{fig:network3}
\end{figure}                           


As can be seen in Figure \ref{fig:network1}, a flow network can be rather simple. We shall start by setting the current flow through each node, on each edge, to zero. Next we must discern a path from the source, $s$, to the sink, $t$.  We'll choose the next node to be $B$, and will set our current minimum capacity for the path to 4. Next, we select $C$ as our next node, updating our minimum capacity to 3. After heading to the sink, $t$, we update our minimum capacity to 2. We can now update the amount of flow passing through each edge in the path to our current minimum capacity, which in this case is 2. The progress so far can be seen in Figure \ref{fig:network2}.

After this, we search for another path that still has capacity for flow. Fortunately, this is another one, as can be seen for $s \leadsto D \leadsto E \leadsto t$, there is a path with a minimum capacity of 1. We can send 1 unit of materials down this path, and it will fill $c(E,\ t)$. Finally, we check if there are any available paths from the source $s$ to the sink $t$, only to find that there are no more paths available with a minimum capacity greater than zero.

From there, we can tally up the total amount of flow heading into the sink from the source, and discover that the maximum flow for this Network Flow is 3.


\section{Implementation}
\lstset{frame=shadowbox, language=Python, rulesepcolor=\color{blue}}

I decided to create my implementation using the Python language, as I am rather familiar with it and it would lead to rapid development. Although initially I had thought about working with C, I realized that it's more important to focus on the core implementation of the algorithm rather than getting bogged down in minor details regarding pointers and structures (again). To increase readability, I decided to create an "edge" class, which would be used in conjunction with associative arrays to delineate edges between nodes.

\subsection{Edge}
\begin{figure*}[t]
\begin{lstlisting}
class edge(object):
        def __init__(self, u, v):
                self.capacity = 0
                self.flow = 0
                self.u, self.v = u, v
\end{lstlisting}
\caption{Node Class in Python}\label{fig:node}
\end{figure*}

\begin{figure*}[t]
\begin{lstlisting}
graph = {}
# initialize graph with edges,
# including a source s and a sink t
total_flow = 0

# start at the source node
node = graph['s']

for i in node:
	# find the least capacity in the path
	minimum_capacity = 9001
	path = []
	# Ensure the sink hasn't been reached,
	# and that there is more capacity available
        while (i.flow < i.capacity and i.u != 't'):
                flow_available = i.capacity - i.flow
                if(minimum_capacity > flow_available):
                        minimum_capacity = flow_available
                path.append(i)
		# stop before the sink
                if (i.v != 't'):
                        i = graph[i.v][0]
                else:
                        break
        total_flow += minimum_capacity

	# update the flow values for each node
        for i in path:
                i.flow += minimum_capacity

return total_flow
\end{lstlisting}
\caption{Ford Fulkerson Algorithm in Python}\label{fig:algo}
\end{figure*}

As can be seen with my implementation of the edge in Figure \ref{fig:node}, I created a simple data structure that has a few member variables. The most obvious is the capacity, which is initially set to zero, as well as the flow, which is also set to zero. The capacity is set at creation of the edge, and is a value greater than zero. The flow is constantly changing during the calculations, as flow is sent into the nodes and set out of them. The $u$ and $v$ member variables are set to the name of the current node, as well as the node that is connected via the current edge. 

\subsection{Algorithm}
The actual algorithm is represented in Figure \ref{fig:algo}. We first begin by initializing a new graph, and set it equal to an empty associative array, also known as a dictionary in Python. We next build our edges, including them under the nodes which they connect, and applying the proper values for $u$ and $v$. 

After we have built our graph, we set our initial node as the source, and begin to iterate through the edges connected to the source node. After this we set our minimum capacity to a set value, in this case a value that is over 9000, as in the domain that this implementation was written for, it is known that no values will be greater than that. We next create an empty list as the path, this is used to keep track of what nodes we are using to transfer our flow to the sink node, $t$.

We now enter a loop, which checks to ensure that we have not maximized the amount of flow that can pass through the edge, as well as checks for the end of the path, represented by reaching the sink. We set the amount of flow available equal to the node's capacity minus the amount of flow currently used. This is clearly just the amount of material that can still be transferred between the two nodes. From there, if the current minimum capacity is greater than the available flow for the current edge, then we'll need to decrease the amount of flow we'll be sending through this path. After this, we'll add the edge to the path. 

We now can move on to the next node. First, however, we check to ensure that the next node is not the sink, as that would show that we are already at the end. Once we have a complete path, we can break out of checking for the minimum available capacity, as we should already have it. We now update the total flow by adding the value of the minimum capacity, which will should how much material will begin flowing from the source to the sink. After this, we iterate through all edges in the path, and increase the amount of flow in each of them by the minimum capacity of the entire path. We repeat this as many times as possible for each edge, and this will eventually give us the maximum flow.
%\section{Other Algorithms}
\section{Conclusion}
Overall, I found the research performed for this paper to be interesting and helpful. Rather than thinking graphs as being representations of traveling salesman problems, or just a graph to represent highways between cities, the concept of a Network Flow representation is exceptional. It leads to several interesting applications in areas such as transportation, networking, and even military tactics. This paper serves as a broad survey over the field of Maximum Flow and Network Flow graphs, and served as an exceptional introduction.

\section*{Acknowledgements}
The author would like to thank Lindsey Hughes for providing a location that was beneficial to study (as well as an epic sandwich). He would also like to express gratitude to Suzie Shdo, who assisted in locating relavant works for this study. And lastly, the author would like to extend a most gracious thanks to his professor, Dr. Erik Linstead, by whose good grace the author is (presumeably) not failed out of school for this class.

Also, a large thanks go out to everyone in the author's life this semester, for putting up with him and helping make it his best yet.



% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation Results}
%\label{fig_sim}
%\end{figure}

% Note that IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command, the
% \label for the overall figure must come after \caption.
% \hfil must be used as a separator to get equal spacing.
% The subfigure.sty package works much the same way, except \subfigure is
% used instead of \subfloat.
%
%\begin{figure*}[!t]
%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%\label{fig_second_case}}}
%\caption{Simulation results}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.


% An example of a floating table. Note that, for IEEE style tables, the 
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that IEEE does not put floats in the very first column - or typically
% anywhere on the first page for that matter. Also, in-text middle ("here")
% positioning is not used. Most IEEE journals/conferences use top floats
% exclusively. Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the \fnbelowfloat
% command of the stfloats package.



%\section{Conclusion}
%The conclusion goes here.
% conference papers do not normally have an appendix


% use section* for acknowledgement
%\section*{Acknowledgment}


%The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,cite}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
%\begin{thebibliography}{1}

%\bibitem{IEEEhowto:kopka}
%H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
%  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

%\end{thebibliography}




% that's all folks
\end{document}
